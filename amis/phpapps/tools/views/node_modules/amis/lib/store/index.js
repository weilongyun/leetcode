"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getStoreById = exports.removeStore = exports.addStore = exports.RegisterStore = exports.IIRendererStore = exports.iRendererStore = exports.RendererStore = void 0;
var tslib_1 = require("tslib");
var mobx_state_tree_1 = require("mobx-state-tree");
require("setimmediate");
var iRenderer_1 = require("./iRenderer");
Object.defineProperty(exports, "iRendererStore", { enumerable: true, get: function () { return iRenderer_1.iRendererStore; } });
Object.defineProperty(exports, "IIRendererStore", { enumerable: true, get: function () { return iRenderer_1.IIRendererStore; } });
var service_1 = require("./service");
var combo_1 = require("./combo");
var form_1 = require("./form");
var crud_1 = require("./crud");
var table_1 = require("./table");
var list_1 = require("./list");
var modal_1 = require("./modal");
var find_1 = tslib_1.__importDefault(require("lodash/find"));
var formItem_1 = require("./formItem");
mobx_state_tree_1.setLivelynessChecking(process.env.NODE_ENV === 'production' ? 'ignore' : 'error');
var allowedStoreList = [
    service_1.ServiceStore,
    form_1.FormStore,
    combo_1.ComboStore,
    crud_1.CRUDStore,
    table_1.TableStore,
    list_1.ListStore,
    modal_1.ModalStore,
    formItem_1.FormItemStore
];
exports.RendererStore = mobx_state_tree_1.types
    .model('RendererStore', {
    storeType: 'RendererStore'
})
    .views(function (self) { return ({
    get fetcher() {
        return mobx_state_tree_1.getEnv(self).fetcher;
    },
    get notify() {
        return mobx_state_tree_1.getEnv(self).notify;
    },
    get isCancel() {
        return mobx_state_tree_1.getEnv(self).isCancel;
    },
    get __() {
        return mobx_state_tree_1.getEnv(self).translate;
    },
    getStoreById: function (id) {
        return getStoreById(id);
    },
    get stores() {
        return stores;
    }
}); })
    .actions(function (self) { return ({
    addStore: function (store) {
        var factory = find_1.default(allowedStoreList, function (item) { return item.name === store.storeType; });
        return addStore(factory.create(store, mobx_state_tree_1.getEnv(self)));
    },
    removeStore: function (store) {
        // store.dispose();
        removeStore(store);
    }
}); });
exports.RegisterStore = function (store) {
    allowedStoreList.push(store);
};
var stores = {};
function addStore(store) {
    if (stores[store.id]) {
        return stores[store.id];
    }
    stores[store.id] = store;
    // drawer dialog 不加进去，否则有些容器就不会自我销毁 store 了。
    if (store.parentId && !/(?:dialog|drawer)$/.test(store.path)) {
        var parent = stores[store.parentId];
        parent.addChildId(store.id);
    }
    cleanUp();
    return store;
}
exports.addStore = addStore;
var toDelete = [];
function removeStore(store) {
    var id = store.id;
    toDelete.push(id);
    store.dispose(cleanUp);
}
exports.removeStore = removeStore;
function cleanUp() {
    var index = toDelete.length - 1;
    while (index >= 0) {
        var id = toDelete[index];
        var store = stores[id];
        if (store && !mobx_state_tree_1.isAlive(store)) {
            delete stores[id];
            toDelete.splice(index, 1);
        }
        else {
            index--;
        }
    }
}
function getStoreById(id) {
    return stores[id];
}
exports.getStoreById = getStoreById;
//# sourceMappingURL=./store/index.js.map
